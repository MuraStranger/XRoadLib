using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Reflection;
using System.Web.Services.Description;
using System.Xml;
using System.Xml.Linq;
using System.Xml.Schema;
using System.Xml.Serialization;
using XRoadLib.Attributes;
using XRoadLib.Extensions;
using XRoadLib.Schema;
using XRoadLib.Serialization;

namespace XRoadLib.Protocols.Description
{
    public sealed class ProducerDefinition : IComparer<XmlSchemaType>
    {
        private const string STANDARD_HEADER_NAME = "RequiredHeaders";

        private readonly Assembly contractAssembly;
        private readonly IProtocol protocol;
        private readonly ISchemaExporter schemaExporter;
        private readonly ISerializerCache serializerCache;
        private readonly uint? version;

        private readonly Binding binding;
        private readonly PortType portType;
        private readonly Port servicePort;
        private readonly Service service;

        private readonly IDictionary<MethodInfo, IDictionary<string, XRoadServiceAttribute>> serviceContracts;

        private readonly IDictionary<XName, TypeDefinition> schemaTypeDefinitions = new Dictionary<XName, TypeDefinition>();
        private readonly IDictionary<Type, TypeDefinition> runtimeTypeDefinitions = new Dictionary<Type, TypeDefinition>();
        private readonly IDictionary<string, XmlSchemaElement> schemaElements = new SortedDictionary<string, XmlSchemaElement>();
        private readonly IDictionary<string, Tuple<MethodInfo, XmlSchemaComplexType, XmlSchemaComplexType, XmlQualifiedName>> operationTypes = new SortedDictionary<string, Tuple<MethodInfo, XmlSchemaComplexType, XmlSchemaComplexType, XmlQualifiedName>>();
        private readonly IList<Message> messages = new List<Message>();
        private readonly ISet<string> requiredImports = new SortedSet<string>();

        public ProducerDefinition(IProtocol protocol, Assembly contractAssembly, uint? version = null)
        {
            if (contractAssembly == null)
                throw new ArgumentNullException(nameof(contractAssembly));
            this.contractAssembly = contractAssembly;

            if (protocol == null)
                throw new ArgumentNullException(nameof(protocol));
            this.protocol = protocol;

            this.version = version;

            schemaExporter = protocol.SchemaExporter;
            serializerCache = protocol.GetSerializerCache(version);

            portType = new PortType { Name = "PortTypeName" };

            binding = new Binding
            {
                Name = "BindingName",
                Type = new XmlQualifiedName(portType.Name, protocol.ProducerNamespace)
            };

            servicePort = new Port
            {
                Name = "PortName",
                Binding = new XmlQualifiedName(binding.Name, protocol.ProducerNamespace)
            };

            service = new Service
            {
                Name = "ServiceName",
                Ports = { servicePort }
            };

            serviceContracts = contractAssembly.GetServiceContracts();

            CollectTypes();
            CollectOperations();
        }

        public void SaveTo(Stream stream)
        {
            var startTime = DateTime.Now;
            using (var writer = XmlWriter.Create(stream, new XmlWriterSettings { Indent = true, IndentChars = "  ", NewLineChars = "\r\n" }))
            {
                writer.WriteStartDocument();

                writer.WriteComment($" WSDL document generated by {GetType().FullName} ");
                writer.WriteComment($" WSDL document generated at {startTime:dd.MM.yyyy HH:mm:ss} ");

                WriteServiceDescription(writer);
                writer.Flush();

                writer.WriteComment($" WSDL document generated in {(DateTime.Now - startTime).TotalMilliseconds} ms. ");

                writer.WriteEndDocument();
                writer.Flush();
            }
        }

        private void CollectTypes()
        {
            AddSystemType<DateTime>("dateTime");
            AddSystemType<DateTime>("date");

            AddSystemType<bool>("boolean");

            AddSystemType<float>("float");
            AddSystemType<double>("double");
            AddSystemType<decimal>("decimal");

            AddSystemType<long>("long");
            AddSystemType<int>("int");
            AddSystemType<short>("short");
            AddSystemType<BigInteger>("integer");

            AddSystemType<string>("string");
            AddSystemType<string>("anyURI");

            AddSystemType<Stream>("base64Binary");
            AddSystemType<Stream>("hexBinary");
            AddSystemType<Stream>("base64");

            foreach (var typeDefinition in contractAssembly.GetTypes().Where(type => type.IsXRoadSerializable()).Select(type => protocol.SchemaExporter.GetTypeDefinition(type)))
            {
                if (typeDefinition.IsAnonymous || typeDefinition.Name == null || typeDefinition.State != DefinitionState.Default)
                    continue;

                if (schemaTypeDefinitions.ContainsKey(typeDefinition.Name))
                    throw new Exception($"Multiple type definitions for same name `{typeDefinition.Name}`.");

                schemaTypeDefinitions.Add(typeDefinition.Name, typeDefinition);
                runtimeTypeDefinitions.Add(typeDefinition.Type, typeDefinition);
            }
        }

        private void CollectOperations()
        {
            foreach (var operationDefinition in serviceContracts.SelectMany(x => x.Value.Select(o => protocol.SchemaExporter.GetOperationDefinition(x.Key, XName.Get(o.Key, protocol.ProducerNamespace)))))
            {
                if (operationDefinition.State != DefinitionState.Default)
                    continue;
            }
        }

        private IEnumerable<XmlSchemaType> BuildTypes(string targetNamespace)
        {
            var types = new SortedSet<XmlSchemaType>(this);

            foreach (var typeDefinition in schemaTypeDefinitions.Values)
            {
                if (typeDefinition.Name.NamespaceName != targetNamespace)
                    continue;

                var schemaType = new XmlSchemaComplexType
                {
                    Name = typeDefinition.Name.LocalName,
                    IsAbstract = typeDefinition.Type.IsAbstract,
                    Annotation = CreateSchemaAnnotation(typeDefinition.Type)
                };

                AddComplexTypeContent(schemaType, typeDefinition, targetNamespace);

                types.Add(schemaType);
            }

            return types;
        }

        private void AddComplexTypeContent(XmlSchemaComplexType schemaType, TypeDefinition typeDefinition, string targetNamespace)
        {
            var contentParticle = new XmlSchemaSequence();

            foreach (var propertyDefinition in GetDescriptionProperties(typeDefinition))
                contentParticle.Items.Add(CreatePropertyElement(propertyDefinition, targetNamespace));

            if (typeDefinition.Type.BaseType != typeof(XRoadSerializable))
            {
                var extension = new XmlSchemaComplexContentExtension
                {
                    BaseTypeName = GetSchemaTypeName(typeDefinition.Type.BaseType, targetNamespace),
                    Particle = contentParticle
                };

                schemaType.ContentModel = new XmlSchemaComplexContent { Content = extension };
            }
            else schemaType.Particle = contentParticle;
        }

        private XmlQualifiedName GetSchemaTypeName(Type type, string targetNamespace)
        {
            var name = type.GetSystemTypeName();
            if (name != null)
                return new XmlQualifiedName(name.LocalName, name.NamespaceName);

            TypeDefinition typeDefinition;
            if (!runtimeTypeDefinitions.TryGetValue(type, out typeDefinition))
                throw new Exception($"Unrecognized type `{type.FullName}`.");

            if (targetNamespace != typeDefinition.Name.NamespaceName)
                requiredImports.Add(typeDefinition.Name.NamespaceName);

            return new XmlQualifiedName(typeDefinition.Name.LocalName, typeDefinition.Name.NamespaceName);
        }

        private XmlSchemaAnnotation CreateSchemaAnnotation(ICustomAttributeProvider source)
        {
            var nodes = source.GetXRoadTitles()
                              .Where(title => !string.IsNullOrWhiteSpace(title.Item2))
                              .Select(title => protocol.CreateTitleElement(title.Item1, title.Item2))
                              .Cast<XmlNode>()
                              .ToArray();

            return nodes.Any() ? new XmlSchemaAnnotation { Items = { new XmlSchemaAppInfo { Markup = nodes } } } : null;
        }

        private void AddBinaryAttribute(XmlSchemaAnnotated schemaElement)
        {
            requiredImports.Add(NamespaceConstants.XMIME);

            schemaElement.UnhandledAttributes = new[] { protocol.Style.CreateExpectedContentType("application/octet-stream") };
        }

        private TypeDefinition GetContentTypeDefinition(IContentDefinition contentDefinition)
        {
            if (contentDefinition.TypeName != null)
                return schemaTypeDefinitions[contentDefinition.TypeName];

            if (runtimeTypeDefinitions.ContainsKey(contentDefinition.RuntimeType))
                return runtimeTypeDefinitions[contentDefinition.RuntimeType];

            return schemaExporter.GetTypeDefinition(contentDefinition.RuntimeType);
        }

        private void SetSchemaElementType(XmlSchemaElement schemaElement, IContentDefinition contentDefinition, string targetNamespace)
        {
            if (typeof(Stream).IsAssignableFrom(contentDefinition.RuntimeType) && contentDefinition.UseXop)
                AddBinaryAttribute(schemaElement);

            var typeDefinition = GetContentTypeDefinition(contentDefinition);
            if (!typeDefinition.IsAnonymous)
            {
                schemaElement.SchemaTypeName = new XmlQualifiedName(typeDefinition.Name.LocalName, typeDefinition.Name.NamespaceName);
                return;
            }

            XmlSchemaType schemaType;
            if (contentDefinition.RuntimeType.IsEnum)
            {
                schemaType = new XmlSchemaSimpleType();
                AddEnumTypeContent(contentDefinition.RuntimeType, (XmlSchemaSimpleType)schemaType, targetNamespace);
            }
            else
            {
                schemaType = new XmlSchemaComplexType();
                AddComplexTypeContent((XmlSchemaComplexType)schemaType, typeDefinition, targetNamespace);
            }
            schemaType.Annotation = CreateSchemaAnnotation(contentDefinition.RuntimeType);

            schemaElement.SchemaType = schemaType;
        }

        private void AddEnumTypeContent(Type type, XmlSchemaSimpleType schemaType, string targetNamespace)
        {
            var restriction = new XmlSchemaSimpleTypeRestriction { BaseTypeName = GetSchemaTypeName(typeof(string), targetNamespace) };

            foreach (var name in Enum.GetNames(type))
            {
                var memberInfo = type.GetMember(name).Single();
                var attribute = memberInfo.GetSingleAttribute<XmlEnumAttribute>();
                restriction.Facets.Add(new XmlSchemaEnumerationFacet { Value = (attribute?.Name).GetValueOrDefault(name) });
            }

            schemaType.Content = restriction;
        }

        private XmlSchemaElement CreatePropertyElement(PropertyDefinition propertyDefinition, string targetNamespace)
        {
            var schemaElement = new XmlSchemaElement
            {
                Name = propertyDefinition.Name?.LocalName,
                Annotation = CreateSchemaAnnotation(propertyDefinition.PropertyInfo)
            };

            if (propertyDefinition.Name == null)
            {
                schemaElement.Name = propertyDefinition.ArrayItemDefinition.Name.LocalName;

                if (propertyDefinition.ArrayItemDefinition.IsOptional)
                    schemaElement.MinOccurs = 0;

                schemaElement.IsNillable = propertyDefinition.ArrayItemDefinition.IsNullable;

                schemaElement.MaxOccursString = "unbounded";

                SetSchemaElementType(schemaElement, propertyDefinition.ArrayItemDefinition, targetNamespace);

                return schemaElement;
            }

            if (propertyDefinition.IsOptional)
                schemaElement.MinOccurs = 0;

            schemaElement.IsNillable = propertyDefinition.IsNullable;

            if (propertyDefinition.ArrayItemDefinition == null)
            {
                SetSchemaElementType(schemaElement, propertyDefinition, targetNamespace);
                return schemaElement;
            }

            var itemElement = new XmlSchemaElement
            {
                Name = propertyDefinition.ArrayItemDefinition.Name.LocalName,
                MaxOccursString = "unbounded"
            };

            if (propertyDefinition.ArrayItemDefinition.IsOptional)
                itemElement.MinOccurs = 0;

            itemElement.IsNillable = propertyDefinition.ArrayItemDefinition.IsNullable;

            SetSchemaElementType(itemElement, propertyDefinition.ArrayItemDefinition, targetNamespace);

            protocol.Style.AddItemElementToArrayElement(schemaElement, itemElement, requiredImports);

            return schemaElement;
        }

        private void WriteServiceDescription(XmlWriter writer)
        {
            //AddOperations();

            var serviceDescription = new ServiceDescription { TargetNamespace = protocol.ProducerNamespace };
            AddServiceDescriptionNamespaces(serviceDescription);

            var schema = new XmlSchema { TargetNamespace = protocol.ProducerNamespace };
            foreach (var requiredImport in requiredImports)
                schema.Includes.Add(new XmlSchemaImport { Namespace = requiredImport, SchemaLocation = requiredImport });

            foreach (var schemaType in BuildTypes(protocol.ProducerNamespace))
                schema.Items.Add(schemaType);

            //AddOperationTypes(schema);
            //AddSchemaElements(schema);

            serviceDescription.Types.Schemas.Add(schema);

            serviceDescription.PortTypes.Add(portType);

            binding.Extensions.Add(protocol.Style.CreateSoapBinding());
            serviceDescription.Bindings.Add(binding);

            var standardHeader = new Message { Name = STANDARD_HEADER_NAME };

            foreach (var requiredHeader in protocol.MandatoryHeaders)
                standardHeader.Parts.Add(new MessagePart { Name = requiredHeader.LocalName, Element = new XmlQualifiedName(requiredHeader.LocalName, requiredHeader.NamespaceName) });

            serviceDescription.Messages.Add(standardHeader);

            foreach (var message in messages)
                serviceDescription.Messages.Add(message);

            servicePort.Extensions.Add(new SoapAddressBinding { Location = "" });

            serviceDescription.Services.Add(service);

            protocol.ExportServiceDescription(serviceDescription);

            serviceDescription.Write(writer);
        }

        private void AddServiceDescriptionNamespaces(DocumentableItem serviceDescription)
        {
            serviceDescription.Namespaces.Add(PrefixConstants.MIME, NamespaceConstants.MIME);
            serviceDescription.Namespaces.Add(PrefixConstants.SOAP, NamespaceConstants.SOAP);
            serviceDescription.Namespaces.Add(PrefixConstants.SOAP_ENV, NamespaceConstants.SOAP_ENV);
            serviceDescription.Namespaces.Add(PrefixConstants.WSDL, NamespaceConstants.WSDL);
            serviceDescription.Namespaces.Add(PrefixConstants.XMIME, NamespaceConstants.XMIME);
            serviceDescription.Namespaces.Add(PrefixConstants.XSD, NamespaceConstants.XSD);
            serviceDescription.Namespaces.Add("", protocol.ProducerNamespace);
        }

        private IEnumerable<PropertyDefinition> GetDescriptionProperties(TypeDefinition typeDefinition)
        {
            return typeDefinition.Type
                                 .GetPropertiesSorted(typeDefinition.ContentComparer, version, p => schemaExporter.GetPropertyDefinition(p, typeDefinition))
                                 .Where(d => d.State == DefinitionState.Default);
        }

        private void AddSystemType<T>(string typeName)
        {
            var typeDefinition = TypeDefinition.SimpleTypeDefinition<T>(typeName);
            schemaExporter.ExportTypeDefinition(typeDefinition);

            if (typeDefinition.Type != null && !runtimeTypeDefinitions.ContainsKey(typeDefinition.Type))
                runtimeTypeDefinitions.Add(typeDefinition.Type, typeDefinition);

            if (typeDefinition.Name != null && !schemaTypeDefinitions.ContainsKey(typeDefinition.Name))
                schemaTypeDefinitions.Add(typeDefinition.Name, typeDefinition);

            //var arrayDefinition = typeDefinition.CreateCollectionDefinition();
            //schemaExporter.ExportTypeDefinition(arrayDefinition);

            //if (arrayDefinition.Type != null && !runtimeTypeDefinitions.ContainsKey(arrayDefinition.Type))
            //    runtimeTypeDefinitions.Add(arrayDefinition.Type, arrayDefinition);

            //if (arrayDefinition.Name != null && !schemaTypeDefinitions.ContainsKey(arrayDefinition.Name))
            //    schemaTypeDefinitions.Add(arrayDefinition.Name, arrayDefinition);
        }

        /*
        private void AddMessageTypes(IDictionary<MethodInfo, List<string>> contractMessages)
        {
            Func<KeyValuePair<MethodInfo, List<string>>, IEnumerable<Tuple<string, MethodInfo>>> selector =
                m => protocol == XRoadProtocol.Version20
                    ? m.Value.Select(n => Tuple.Create(n, m.Key))
                    : Enumerable.Repeat(Tuple.Create(GetOperationNameFromMethodInfo(m.Key), m.Key), 1);

            foreach (var operation in contractMessages.SelectMany(selector))
                AddMessageType(operation.Item1, operation.Item2);
        }

        private void AddOperation(string operationName, XRoadServiceAttribute operationContract, MethodInfo methodInfo)
        {
            if (operationContract.IsHidden || (version.HasValue && !operationContract.ExistsInVersion(version.Value)))
                return;

            BuildOperationElements(operationName, methodInfo, operationContract.IsAbstract);

            if (operationContract.IsAbstract)
                return;

            var serviceVersion = version.GetValueOrDefault(operationContract.AddedInVersion);

            var operationBinding = new OperationBinding
            {
                Name = operationName,
                Extensions = { xRoadSchema.CreateXRoadVersionBinding(serviceVersion) },
                Input = new InputBinding(),
                Output = new OutputBinding()
            };

            BuildOperationBinding(operationBinding, methodInfo);

            binding.Operations.Add(operationBinding);
        }

        private void AddOperations()
        {
            foreach (var op in serviceContracts.SelectMany(x => x.Value.Select(y => Tuple.Create(y.Key, y.Value, x.Key))).OrderBy(x => x.Item1))
                AddOperation(op.Item1, op.Item2, op.Item3);
        }

        private void BuildOperationElements(string name, MethodInfo methodContract, bool isExported)
        {
            var importAttribute = methodContract.GetImportAttribute(protocol);
            if (importAttribute != null)
            {
                BuildImportedOperationElements(name, methodContract, importAttribute);
                return;
            }

            var operationTypeName = GetOperationTypeName(name, methodContract);

            var requestElement = new XmlSchemaElement
            {
                Name = name,
                SchemaTypeName = operationTypeName.Item1
            };

            var responseElement = new XmlSchemaElement
            {
                Name = $"{name}Response",
                SchemaTypeName = operationTypeName.Item2
            };

            schemaElements.Add(requestElement.Name, requestElement);
            schemaElements.Add(responseElement.Name, responseElement);

            var inputMessage = CreateOperationMessage(requestElement, methodContract);
            var outputMessage = CreateOperationMessage(responseElement, methodContract, inputMessage);

            if (!isExported)
            {
                var operation = new Operation { Name = name, DocumentationElement = xRoadSchema.CreateDocumentationFor(methodContract) };

                operation.Messages.Add(new OperationInput { Message = new XmlQualifiedName(inputMessage.Name, targetNamespace) });
                operation.Messages.Add(new OperationOutput { Message = new XmlQualifiedName(outputMessage.Name, targetNamespace) });

                portType.Operations.Add(operation);
            }

            messages.Add(inputMessage);
            messages.Add(outputMessage);
        }

        private void AddMessageType(string operationName, MethodInfo method)
        {
            var requestName = string.Format(requestTypeNameFormat, operationName);
            var responseName = string.Format(responseTypeNameFormat, operationName);

            if (IsExistingType(requestName) || IsExistingType(responseName))
                throw new Exception($"Operation type `{requestName}` already exists with the same name.");

            var requestType = CreateOperationRequestType(requestName, method);
            var responseType = CreateResponseType(responseName, method, (XmlSchemaGroupBase)requestType.Item2?.Particle, operationName);

            operationTypes.Add(requestName, Tuple.Create(method, requestType.Item2, responseType, requestType.Item1));
        }

        private bool IsExistingType(string typeName)
        {
            return schemaBuilder[typeName] || operationTypes.ContainsKey(typeName);
        }

        private void BuildImportedOperationElements(string name, MethodInfo methodContract, XRoadImportAttribute importAttribute)
        {
            var importNamespace = ((ISchemaImportProvider)Activator.CreateInstance(importAttribute.SchemaImportProvider)).SchemaNamespace;

            var operationTypeName = Tuple.Create(new XmlQualifiedName(importAttribute.RequestPart, importNamespace),
                                                 new XmlQualifiedName(importAttribute.ResponsePart, importNamespace));

            var extraParts = methodContract.GetExtraMessageParts().ToList();

            var inputMessage = new Message
            {
                Name = string.Format(requestMessageNameFormat, name)
            };

            inputMessage.Parts.Add(
                protocol == XRoadProtocol.Version20
                    ? new MessagePart { Name = "keha", Type = operationTypeName.Item1 }
                    : new MessagePart { Name = "body", Element = operationTypeName.Item1 });

            var outputMessage = new Message
            {
                Name = string.Format(responseMessageNameFormat, name)
            };

            if (protocol == XRoadProtocol.Version20)
                outputMessage.Parts.Add(new MessagePart { Name = "paring", Type = operationTypeName.Item1 });

            outputMessage.Parts.Add(
                protocol == XRoadProtocol.Version20
                    ? new MessagePart { Name = "keha", Type = operationTypeName.Item2 }
                    : new MessagePart { Name = "body", Element = operationTypeName.Item2 });

            if (protocol == XRoadProtocol.Version20)
                foreach (var part in extraParts)
                {
                    var message = part.Direction == MessagePartDirection.Input ? inputMessage : outputMessage;
                    message.Parts.Add(new MessagePart { Name = part.PartName, Type = new XmlQualifiedName(part.TypeName, importNamespace) });
                }

            var operation = new Operation { Name = name, DocumentationElement = xRoadSchema.CreateDocumentationFor(methodContract) };

            operation.Messages.Add(new OperationInput { Message = new XmlQualifiedName(inputMessage.Name, targetNamespace) });
            operation.Messages.Add(new OperationOutput { Message = new XmlQualifiedName(outputMessage.Name, targetNamespace) });

            portType.Operations.Add(operation);

            messages.Add(inputMessage);
            messages.Add(outputMessage);
        }

        private void AddSoapOperationBinding(DocumentableItem operationBinding)
        {
            operationBinding.Extensions.Add(new SoapOperationBinding
            {
                Style = protocol == XRoadProtocol.Version20 ? SoapBindingStyle.Rpc : SoapBindingStyle.Document,
                SoapAction = ""
            });
        }

        private SoapBodyBinding CreateSoapBodyBinding()
        {
            return protocol == XRoadProtocol.Version20
                ? new SoapBodyBinding { Use = SoapBindingUse.Encoded, Namespace = targetNamespace, Encoding = NamespaceConstants.SOAP_ENC }
                : new SoapBodyBinding { Use = SoapBindingUse.Literal };
        }

        private SoapHeaderBinding CreateSoapHeaderBinding(string headerName)
        {
            return new SoapHeaderBinding
            {
                Message = new XmlQualifiedName(standardHeaderName, targetNamespace),
                Part = headerName,
                Use = protocol == XRoadProtocol.Version20 ? SoapBindingUse.Encoded : SoapBindingUse.Literal,
                Namespace = protocol == XRoadProtocol.Version20 ? xroadNamespace : null,
                Encoding = protocol == XRoadProtocol.Version20 ? NamespaceConstants.SOAP_ENC : null
            };
        }

        private MimePart BuildMultipartOperationBinding()
        {
            var messagePart = new MimePart { Extensions = { CreateSoapBodyBinding() } };

            foreach (var headerBinding in requiredHeaders.Select(CreateSoapHeaderBinding))
                messagePart.Extensions.Add(xRoadSchema.CreateSoapHeader(headerBinding));

            return messagePart;
        }

        private void BuildOperationBinding(OperationBinding operationBinding, MethodInfo methodContract)
        {
            AddSoapOperationBinding(operationBinding);

            if (protocol == XRoadProtocol.Version20 && methodContract.HasMultipartRequest())
            {
                operationBinding.Input.Extensions.Add(
                    new MimeMultipartRelatedBinding
                    {
                        Parts =
                        {
                            BuildMultipartOperationBinding(),
                            new MimePart { Extensions = { new MimeContentBinding { Part = "p1", Type = "application/binary" } } }
                        }
                    });
            }
            else
            {
                operationBinding.Input.Extensions.Add(CreateSoapBodyBinding());
                foreach (var headerBinding in requiredHeaders.Select(CreateSoapHeaderBinding))
                    operationBinding.Input.Extensions.Add(headerBinding);
            }

            if (protocol == XRoadProtocol.Version20 && methodContract.HasMultipartResponse())
            {
                operationBinding.Output.Extensions.Add(
                    new MimeMultipartRelatedBinding
                    {
                        Parts =
                        {
                            BuildMultipartOperationBinding(),
                            new MimePart { Extensions = { new MimeContentBinding { Part = "p2", Type = "application/binary" } } }
                        }
                    });
            }
            else
            {
                operationBinding.Output.Extensions.Add(CreateSoapBodyBinding());
                foreach (var headerBinding in requiredHeaders.Select(CreateSoapHeaderBinding))
                    operationBinding.Output.Extensions.Add(headerBinding);
            }
        }

        private Tuple<XmlQualifiedName, XmlQualifiedName> GetOperationTypeName(string operationName, MethodInfo methodContract)
        {
            var name = protocol == XRoadProtocol.Version20 ? operationName : GetOperationNameFromMethodInfo(methodContract);

            var requestTypeName = string.Format(requestTypeNameFormat, name);
            var responseTypeName = string.Format(responseTypeNameFormat, name);

            Tuple<MethodInfo, XmlSchemaComplexType, XmlSchemaComplexType, XmlQualifiedName> value;
            if (!operationTypes.TryGetValue(requestTypeName, out value) || methodContract != value.Item1)
                throw new Exception($"Unrecognized type `{requestTypeName}`");

            return Tuple.Create(new XmlQualifiedName(requestTypeName, targetNamespace),
                                new XmlQualifiedName(responseTypeName, targetNamespace));
        }

        private Tuple<XmlQualifiedName, XmlSchemaComplexType> CreateOperationRequestType(string requestName, MethodInfo method)
        {
            var parameters = method.GetParameters().Where(p => !version.HasValue || p.ExistsInVersion(version.Value)).ToList();
            var complexType = new XmlSchemaComplexType { Name = requestName, Annotation = schemaBuilder.CreateSchemaAnnotation(method) };
            var requestElement = new XmlSchemaElement { Name = "request" };

            if (parameters.Count == 0)
            {
                if (protocol != XRoadProtocol.Version20)
                    requestElement.SchemaType = new XmlSchemaComplexType { Particle = new XmlSchemaSequence() };

                complexType.Particle = protocol != XRoadProtocol.Version20 ? new XmlSchemaSequence { Items = { requestElement } } : new XmlSchemaSequence();

                return Tuple.Create((XmlQualifiedName)null, complexType);
            }

            if (parameters.Count == 1)
            {
                var parameter = parameters.Single();
                var parameterElement = schemaBuilder.CreateSchemaElement(parameter, true);
                if (string.IsNullOrWhiteSpace(parameterElement.Name))
                {
                    if (protocol == XRoadProtocol.Version20)
                        return parameterElement.SchemaType != null
                            ? Tuple.Create((XmlQualifiedName)null, (XmlSchemaComplexType)parameterElement.SchemaType)
                            : Tuple.Create(parameterElement.SchemaTypeName, (XmlSchemaComplexType)null);

                    parameterElement.Name = "request";
                    complexType.Particle = new XmlSchemaSequence { Items = { parameterElement } };

                    return Tuple.Create((XmlQualifiedName)null, complexType);
                }
            }

            var schemaParticle = operationConfiguration?.GetParameterLayout(method) == XRoadContentLayoutMode.Flexible
                ? (XmlSchemaGroupBase)new XmlSchemaAll()
                : new XmlSchemaSequence();

            foreach (var parameter in parameters)
                schemaParticle.Items.Add(schemaBuilder.CreateSchemaElement(parameter));

            if (protocol == XRoadProtocol.Version20)
                complexType.Particle = schemaParticle;
            else
            {
                requestElement.SchemaType = new XmlSchemaComplexType { Particle = schemaParticle };
                complexType.Particle = new XmlSchemaSequence { Items = { requestElement } };
            }

            return Tuple.Create((XmlQualifiedName)null, complexType);
        }

        private XmlSchemaComplexType CreateResponseType(string responseName, MethodInfo method, XmlSchemaGroupBase requestSequence, string operationName)
        {
            var complexType = new XmlSchemaComplexType { Name = responseName, Annotation = schemaBuilder.CreateSchemaAnnotation(method) };

            var faultSequence = schemaBuilder.CreateFaultSequence(method);
            if (faultSequence != null && method.ReturnType == typeof(void))
                faultSequence.MinOccurs = 0;

            if (protocol == XRoadProtocol.Version20)
            {
                if (method.ReturnType == typeof(void))
                {
                    complexType.Particle = faultSequence != null ? new XmlSchemaSequence { Items = { faultSequence } } : new XmlSchemaSequence();
                    return complexType;
                }

                var resultElement = schemaBuilder.CreateSchemaElement(method.ReturnParameter);
                if (string.IsNullOrWhiteSpace(resultElement.Name))
                {
                    if (faultSequence != null)
                        throw new Exception($"Method `{operationName}` return parameter element name cannot be empty.");

                    if (!method.ReturnType.IsArray)
                        return null;

                    complexType.ContentModel = (XmlSchemaComplexContent)((XmlSchemaComplexType)resultElement.SchemaType).ContentModel;
                }
                else
                {
                    complexType.Particle = faultSequence != null ? new XmlSchemaSequence { Items = { new XmlSchemaChoice { Items = { faultSequence, resultElement } } } }
                                                                 : new XmlSchemaSequence { Items = { resultElement } };
                }

                return complexType;
            }

            var responseSequence = new XmlSchemaSequence();
            var responseElement = new XmlSchemaElement { Name = "response", SchemaType = new XmlSchemaComplexType { Particle = responseSequence } };

            if (method.ReturnType != typeof(void))
            {
                var resultElement = schemaBuilder.CreateSchemaElement(method.ReturnParameter);
                if (string.IsNullOrWhiteSpace(resultElement.Name))
                {
                    if (faultSequence != null)
                        throw new Exception($"Method `{operationName}` return parameter element name cannot be empty.");

                    resultElement.Name = "response";
                    responseElement = resultElement;
                }
                else
                {
                    if (faultSequence != null)
                        responseSequence.Items.Add(new XmlSchemaChoice { Items = { faultSequence, resultElement } });
                    else responseSequence.Items.Add(resultElement);
                }
            }
            else if (faultSequence != null)
                responseSequence.Items.Add(faultSequence);

            return new XmlSchemaComplexType
            {
                Name = responseName,
                Particle = new XmlSchemaSequence { Items = { requestSequence.Items[0], responseElement } },
                Annotation = schemaBuilder.CreateSchemaAnnotation(method)
            };
        }

        private void AddOperationTypes(XmlSchema schema)
        {
            foreach (var operationType in operationTypes.Values.Select(x => x.Item2).Concat(operationTypes.Values.Select(x => x.Item3)).Where(x => x != null).OrderBy(x => x.Name))
                schema.Items.Add(operationType);
        }

        private void AddSchemaElements(XmlSchema schema)
        {
            if (protocol == XRoadProtocol.Version20)
                return;

            foreach (var schemaElement in schemaElements)
                schema.Items.Add(schemaElement.Value);
        }

        private Message CreateOperationMessage(XmlSchemaElement element, MethodInfo methodContract, Message inputMessage = null)
        {
            if (protocol != XRoadProtocol.Version20)
                return new Message
                {
                    Name = element.Name,
                    Parts = { new MessagePart { Name = "body", Element = new XmlQualifiedName(element.Name, targetNamespace) } }
                };

            var message = new Message { Name = element.SchemaTypeName.Name };

            if (inputMessage != null)
                message.Parts.Add(new MessagePart { Name = "paring", Type = inputMessage.Parts[0].Type });

            if (inputMessage != null && !methodContract.ReturnType.IsArray)
                message.Parts.Add(new MessagePart { Name = "keha", Type = schemaBuilder.GetSchemaTypeName(methodContract.ReturnType) });
            else message.Parts.Add(new MessagePart { Name = "keha", Type = element.SchemaTypeName });

            if (inputMessage == null && methodContract.HasMultipartRequest())
                message.Parts.Add(new MessagePart { Name = "file", Type = schemaBuilder.GetSchemaTypeName(typeof(Stream)) });

            if (inputMessage != null && methodContract.HasMultipartResponse())
                message.Parts.Add(new MessagePart { Name = "file", Type = schemaBuilder.GetSchemaTypeName(typeof(Stream)) });

            return message;
        }

        
        */

        public int Compare(XmlSchemaType x, XmlSchemaType y)
        {
            return string.Compare(x.Name, y.Name, StringComparison.InvariantCulture);
        }
    }
}
